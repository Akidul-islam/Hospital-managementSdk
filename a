[33mcommit b35a2e93c35a0fc14f88fe7294465dcd9383e44a[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m)[m
Author: unknown <akidulislam5793@gmail.com>
Date:   Thu May 4 23:45:27 2023 +0600

    inital frist commits

[1mdiff --git a/index.js b/index.js[m
[1mnew file mode 100644[m
[1mindex 0000000..2ebd995[m
[1m--- /dev/null[m
[1m+++ b/index.js[m
[36m@@ -0,0 +1,134 @@[m
[32m+[m[32mimport axios from 'axios';[m
[32m+[m
[32m+[m[32mclass HospitalManagementSDK {[m
[32m+[m[32m  constructor(apiKey) {[m
[32m+[m[32m    this.baseURL = 'https://some.com/api'; // Replace with your API base URL[m
[32m+[m[32m    this.apiKey = apiKey;[m
[32m+[m[32m    this.axiosInstance = axios.create({[m
[32m+[m[32m      baseURL: this.baseURL,[m
[32m+[m[32m      headers: {[m
[32m+[m[32m        Authorization: `Bearer ${this.apiKey}`,[m
[32m+[m[32m      },[m
[32m+[m[32m    });[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // User authentication methods[m
[32m+[m[32m  async login(username, password) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/auth/login', {[m
[32m+[m[32m      username,[m
[32m+[m[32m      password,[m
[32m+[m[32m    });[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async register(user) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/auth/register', user);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Patient management methods[m
[32m+[m
[32m+[m[32m  async getPatients() {[m
[32m+[m[32m    const response = await this.axiosInstance.get('/patients');[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async getPatientById(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.get(`/patients/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async addPatient(patient) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/patients', patient);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async updatePatient(id, patient) {[m
[32m+[m[32m    const response = await this.axiosInstance.put(`/patients/${id}`, patient);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async deletePatient(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.delete(`/patients/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Doctor management methods[m
[32m+[m
[32m+[m[32m  async getDoctors() {[m
[32m+[m[32m    const response = await this.axiosInstance.get('/doctors');[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async getDoctorById(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.get(`/doctors/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async addDoctor(doctor) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/doctors', doctor);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async updateDoctor(id, doctor) {[m
[32m+[m[32m    const response = await this.axiosInstance.put(`/doctors/${id}`, doctor);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async deleteDoctor(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.delete(`/doctors/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Appointment management methods[m
[32m+[m
[32m+[m[32m  async bookAppointment(doctorId, patientId, appointmentDate) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/appointments', {[m
[32m+[m[32m      doctorId,[m
[32m+[m[32m      patientId,[m
[32m+[m[32m      appointmentDate,[m
[32m+[m[32m    });[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Hospital staff management methods[m
[32m+[m
[32m+[m[32m  async getHospitalStaff() {[m
[32m+[m[32m    const response = await this.axiosInstance.get('/staff');[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async getHospitalStaffMember(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.get(`/staff/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async addHospitalStaffMember(staffMember) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/staff', staffMember);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async updateHospitalStaffMember(id, staffMember) {[m
[32m+[m[32m    const response = await this.axiosInstance.put(`/staff/${id}`, staffMember);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  async deleteHospitalStaffMember(id) {[m
[32m+[m[32m    const response = await this.axiosInstance.delete(`/staff/${id}`);[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // Payment management methods[m
[32m+[m
[32m+[m[32m  async makePayment(amount, cardNumber, expirationDate, cvv) {[m
[32m+[m[32m    const response = await this.axiosInstance.post('/payments', {[m
[32m+[m[32m      amount,[m
[32m+[m[32m      cardNumber,[m
[32m+[m[32m      expirationDate,[m
[32m+[m[32m      cvv,[m
[32m+[m[32m    });[m
[32m+[m[32m    return response.data;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mmodule.exports = HospitalManagementSDK;[m
[1mdiff --git a/node_modules/.yarn-integrity b/node_modules/.yarn-integrity[m
[1mnew file mode 100644[m
[1mindex 0000000..a199a0d[m
[1m--- /dev/null[m
[1m+++ b/node_modules/.yarn-integrity[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32m{[m
[32m+[m[32m  "systemParams": "win32-x64-93",[m
[32m+[m[32m  "modulesFolders": [[m
[32m+[m[32m    "node_modules"[m
[32m+[m[32m  ],[m
[32m+[m[32m  "flags": [],[m
[32m+[m[32m  "linkedModules": [],[m
[32m+[m[32m  "topLevelPatterns": [[m
[32m+[m[32m    "axios@^1.4.0"[m
[32m+[m[32m  ],[m
[32m+[m[32m  "lockfileEntries": {[m
[32m+[m[32m    "asynckit@^0.4.0": "https://registry.yarnpkg.com/asynckit/-/asynckit-0.4.0.tgz#c79ed97f7f34cb8f2ba1bc9790bcc366474b4b79",[m
[32m+[m[32m    "axios@^1.4.0": "https://registry.yarnpkg.com/axios/-/axios-1.4.0.tgz#38a7bf1224cd308de271146038b551d725f0be1f",[m
[32m+[m[32m    "combined-stream@^1.0.8": "https://registry.yarnpkg.com/combined-stream/-/combined-stream-1.0.8.tgz#c3d45a8b34fd730631a110a8a2520682b31d5a7f",[m
[32m+[m[32m    "delayed-stream@~1.0.0": "https://registry.yarnpkg.com/delayed-stream/-/delayed-stream-1.0.0.tgz#df3ae199acadfb7d440aaae0b29e2272b24ec619",[m
[32m+[m[32m    "follow-redirects@^1.15.0": "https://registry.yarnpkg.com/follow-redirects/-/follow-redirects-1.15.2.tgz#b460864144ba63f2681096f274c4e57026da2c13",[m
[32m+[m[32m    "form-data@^4.0.0": "https://registry.yarnpkg.com/form-data/-/form-data-4.0.0.tgz#93919daeaf361ee529584b9b31664dc12c9fa452",[m
[32m+[m[32m    "mime-db@1.52.0": "https://registry.yarnpkg.com/mime-db/-/mime-db-1.52.0.tgz#bbabcdc02859f4987301c856e3387ce5ec43bf70",[m
[32m+[m[32m    "mime-types@^2.1.12": "https://registry.yarnpkg.com/mime-types/-/mime-types-2.1.35.tgz#381a871b62a734450660ae3deee44813f70d959a",[m
[32m+[m[32m    "proxy-from-env@^1.1.0": "https://registry.yarnpkg.com/proxy-from-env/-/proxy-from-env-1.1.0.tgz#e102f16ca355424865755d2c9e8ea4f24d58c3e2"[m
[32m+[m[32m  },[m
[32m+[m[32m  "files": [],[m
[32m+[m[32m  "artifacts": {}[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/node_modules/asynckit/LICENSE b/node_modules/asynckit/LICENSE[m
[1mnew file mode 100644[m
[1mindex 0000000..c9eca5d[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/LICENSE[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mThe MIT License (MIT)[m
[32m+[m
[32m+[m[32mCopyright (c) 2016 Alex Indigo[m
[32m+[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a copy[m
[32m+[m[32mof this software and associated documentation files (the "Software"), to deal[m
[32m+[m[32min the Software without restriction, including without limitation the rights[m
[32m+[m[32mto use, copy, modify, merge, publish, distribute, sublicense, and/or sell[m
[32m+[m[32mcopies of the Software, and to permit persons to whom the Software is[m
[32m+[m[32mfurnished to do so, subject to the following conditions:[m
[32m+[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included in all[m
[32m+[m[32mcopies or substantial portions of the Software.[m
[32m+[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m
[32m+[m[32mAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m
[32m+[m[32mLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m
[32m+[m[32mOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m
[32m+[m[32mSOFTWARE.[m
[1mdiff --git a/node_modules/asynckit/README.md b/node_modules/asynckit/README.md[m
[1mnew file mode 100644[m
[1mindex 0000000..ddcc7e6[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/README.md[m
[36m@@ -0,0 +1,233 @@[m
[32m+[m[32m# asynckit [![NPM Module](https://img.shields.io/npm/v/asynckit.svg?style=flat)](https://www.npmjs.com/package/asynckit)[m
[32m+[m
[32m+[m[32mMinimal async jobs utility library, with streams support.[m
[32m+[m
[32m+[m[32m[![PhantomJS Build](https://img.shields.io/travis/alexindigo/asynckit/v0.4.0.svg?label=browser&style=flat)](https://travis-ci.org/alexindigo/asynckit)[m
[32m+[m[32m[![Linux Build](https://img.shields.io/travis/alexindigo/asynckit/v0.4.0.svg?label=linux:0.12-6.x&style=flat)](https://travis-ci.org/alexindigo/asynckit)[m
[32m+[m[32m[![Windows Build](https://img.shields.io/appveyor/ci/alexindigo/asynckit/v0.4.0.svg?label=windows:0.12-6.x&style=flat)](https://ci.appveyor.com/project/alexindigo/asynckit)[m
[32m+[m
[32m+[m[32m[![Coverage Status](https://img.shields.io/coveralls/alexindigo/asynckit/v0.4.0.svg?label=code+coverage&style=flat)](https://coveralls.io/github/alexindigo/asynckit?branch=master)[m
[32m+[m[32m[![Dependency Status](https://img.shields.io/david/alexindigo/asynckit/v0.4.0.svg?style=flat)](https://david-dm.org/alexindigo/asynckit)[m
[32m+[m[32m[![bitHound Overall Score](https://www.bithound.io/github/alexindigo/asynckit/badges/score.svg)](https://www.bithound.io/github/alexindigo/asynckit)[m
[32m+[m
[32m+[m[32m<!-- [![Readme](https://img.shields.io/badge/readme-tested-brightgreen.svg?style=flat)](https://www.npmjs.com/package/reamde) -->[m
[32m+[m
[32m+[m[32mAsyncKit provides harness for `parallel` and `serial` iterators over list of items represented by arrays or objects.[m
[32m+[m[32mOptionally it accepts abort function (should be synchronously return by iterator for each item), and terminates left over jobs upon an error event. For specific iteration order built-in (`ascending` and `descending`) and custom sort helpers also supported, via `asynckit.serialOrdered` method.[m
[32m+[m
[32m+[m[32mIt ensures async operations to keep behavior more stable and prevent `Maximum call stack size exceeded` errors, from sync iterators.[m
[32m+[m
[32m+[m[32m| compression        |     size |[m
[32m+[m[32m| :----------------- | -------: |[m
[32m+[m[32m| asynckit.js        | 12.34 kB |[m
[32m+[m[32m| asynckit.min.js    |  4.11 kB |[m
[32m+[m[32m| asynckit.min.js.gz |  1.47 kB |[m
[32m+[m
[32m+[m
[32m+[m[32m## Install[m
[32m+[m
[32m+[m[32m```sh[m
[32m+[m[32m$ npm install --save asynckit[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m## Examples[m
[32m+[m
[32m+[m[32m### Parallel Jobs[m
[32m+[m
[32m+[m[32mRuns iterator over provided array in parallel. Stores output in the `result` array,[m
[32m+[m[32mon the matching positions. In unlikely event of an error from one of the jobs,[m
[32m+[m[32mwill terminate rest of the active jobs (if abort function is provided)[m
[32m+[m[32mand return error along with salvaged data to the main callback function.[m
[32m+[m
[32m+[m[32m#### Input Array[m
[32m+[m
[32m+[m[32m```javascript[m
[32m+[m[32mvar parallel = require('asynckit').parallel[m
[32m+[m[32m  , assert   = require('assert')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ][m
[32m+[m[32m  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ][m
[32m+[m[32m  , expectedTarget = [ 1, 1, 2, 4, 8, 16, 32, 64 ][m
[32m+[m[32m  , target         = [][m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mparallel(source, asyncJob, function(err, result)[m
[32m+[m[32m{[m
[32m+[m[32m  assert.deepEqual(result, expectedResult);[m
[32m+[m[32m  assert.deepEqual(target, expectedTarget);[m
[32m+[m[32m});[m
[32m+[m
[32m+[m[32m// async job accepts one element from the array[m
[32m+[m[32m// and a callback function[m
[32m+[m[32mfunction asyncJob(item, cb)[m
[32m+[m[32m{[m
[32m+[m[32m  // different delays (in ms) per item[m
[32m+[m[32m  var delay = item * 25;[m
[32m+[m
[32m+[m[32m  // pretend different jobs take different time to finish[m
[32m+[m[32m  // and not in consequential order[m
[32m+[m[32m  var timeoutId = setTimeout(function() {[m
[32m+[m[32m    target.push(item);[m
[32m+[m[32m    cb(null, item * 2);[m
[32m+[m[32m  }, delay);[m
[32m+[m
[32m+[m[32m  // allow to cancel "leftover" jobs upon error[m
[32m+[m[32m  // return function, invoking of which will abort this job[m
[32m+[m[32m  return clearTimeout.bind(null, timeoutId);[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32mMore examples could be found in [test/test-parallel-array.js](test/test-parallel-array.js).[m
[32m+[m
[32m+[m[32m#### Input Object[m
[32m+[m
[32m+[m[32mAlso it supports named jobs, listed via object.[m
[32m+[m
[32m+[m[32m```javascript[m
[32m+[m[32mvar parallel = require('asynckit/parallel')[m
[32m+[m[32m  , assert   = require('assert')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar source         = { first: 1, one: 1, four: 4, sixteen: 16, sixtyFour: 64, thirtyTwo: 32, eight: 8, two: 2 }[m
[32m+[m[32m  , expectedResult = { first: 2, one: 2, four: 8, sixteen: 32, sixtyFour: 128, thirtyTwo: 64, eight: 16, two: 4 }[m
[32m+[m[32m  , expectedTarget = [ 1, 1, 2, 4, 8, 16, 32, 64 ][m
[32m+[m[32m  , expectedKeys   = [ 'first', 'one', 'two', 'four', 'eight', 'sixteen', 'thirtyTwo', 'sixtyFour' ][m
[32m+[m[32m  , target         = [][m
[32m+[m[32m  , keys           = [][m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mparallel(source, asyncJob, function(err, result)[m
[32m+[m[32m{[m
[32m+[m[32m  assert.deepEqual(result, expectedResult);[m
[32m+[m[32m  assert.deepEqual(target, expectedTarget);[m
[32m+[m[32m  assert.deepEqual(keys, expectedKeys);[m
[32m+[m[32m});[m
[32m+[m
[32m+[m[32m// supports full value, key, callback (shortcut) interface[m
[32m+[m[32mfunction asyncJob(item, key, cb)[m
[32m+[m[32m{[m
[32m+[m[32m  // different delays (in ms) per item[m
[32m+[m[32m  var delay = item * 25;[m
[32m+[m
[32m+[m[32m  // pretend different jobs take different time to finish[m
[32m+[m[32m  // and not in consequential order[m
[32m+[m[32m  var timeoutId = setTimeout(function() {[m
[32m+[m[32m    keys.push(key);[m
[32m+[m[32m    target.push(item);[m
[32m+[m[32m    cb(null, item * 2);[m
[32m+[m[32m  }, delay);[m
[32m+[m
[32m+[m[32m  // allow to cancel "leftover" jobs upon error[m
[32m+[m[32m  // return function, invoking of which will abort this job[m
[32m+[m[32m  return clearTimeout.bind(null, timeoutId);[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32mMore examples could be found in [test/test-parallel-object.js](test/test-parallel-object.js).[m
[32m+[m
[32m+[m[32m### Serial Jobs[m
[32m+[m
[32m+[m[32mRuns iterator over provided array sequentially. Stores output in the `result` array,[m
[32m+[m[32mon the matching positions. In unlikely event of an error from one of the jobs,[m
[32m+[m[32mwill not proceed to the rest of the items in the list[m
[32m+[m[32mand return error along with salvaged data to the main callback function.[m
[32m+[m
[32m+[m[32m#### Input Array[m
[32m+[m
[32m+[m[32m```javascript[m
[32m+[m[32mvar serial = require('asynckit/serial')[m
[32m+[m[32m  , assert = require('assert')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ][m
[32m+[m[32m  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ][m
[32m+[m[32m  , expectedTarget = [ 0, 1, 2, 3, 4, 5, 6, 7 ][m
[32m+[m[32m  , target         = [][m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mserial(source, asyncJob, function(err, result)[m
[32m+[m[32m{[m
[32m+[m[32m  assert.deepEqual(result, expectedResult);[m
[32m+[m[32m  assert.deepEqual(target, expectedTarget);[m
[32m+[m[32m});[m
[32m+[m
[32m+[m[32m// extended interface (item, key, callback)[m
[32m+[m[32m// also supported for arrays[m
[32m+[m[32mfunction asyncJob(item, key, cb)[m
[32m+[m[32m{[m
[32m+[m[32m  target.push(key);[m
[32m+[m
[32m+[m[32m  // it will be automatically made async[m
[32m+[m[32m  // even it iterator "returns" in the same event loop[m
[32m+[m[32m  cb(null, item * 2);[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32mMore examples could be found in [test/test-serial-array.js](test/test-serial-array.js).[m
[32m+[m
[32m+[m[32m#### Input Object[m
[32m+[m
[32m+[m[32mAlso it supports named jobs, listed via object.[m
[32m+[m
[32m+[m[32m```javascript[m
[32m+[m[32mvar serial = require('asynckit').serial[m
[32m+[m[32m  , assert = require('assert')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar source         = [ 1, 1, 4, 16, 64, 32, 8, 2 ][m
[32m+[m[32m  , expectedResult = [ 2, 2, 8, 32, 128, 64, 16, 4 ][m
[32m+[m[32m  , expectedTarget = [ 0, 1, 2, 3, 4, 5, 6, 7 ][m
[32m+[m[32m  , target         = [][m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar source         = { first: 1, one: 1, four: 4, sixteen: 16, sixtyFour: 64, thirtyTwo: 32, eight: 8, two: 2 }[m
[32m+[m[32m  , expectedResult = { first: 2, one: 2, four: 8, sixteen: 32, sixtyFour: 128, thirtyTwo: 64, eight: 16, two: 4 }[m
[32m+[m[32m  , expectedTarget = [ 1, 1, 4, 16, 64, 32, 8, 2 ][m
[32m+[m[32m  , target         = [][m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m
[32m+[m[32mserial(source, asyncJob, function(err, result)[m
[32m+[m[32m{[m
[32m+[m[32m  assert.deepEqual(result, expectedResult);[m
[32m+[m[32m  assert.deepEqual(target, expectedTarget);[m
[32m+[m[32m});[m
[32m+[m
[32m+[m[32m// shortcut interface (item, callback)[m
[32m+[m[32m// works for object as well as for the arrays[m
[32m+[m[32mfunction asyncJob(item, cb)[m
[32m+[m[32m{[m
[32m+[m[32m  target.push(item);[m
[32m+[m
[32m+[m[32m  // it will be automatically made async[m
[32m+[m[32m  // even it iterator "returns" in the same event loop[m
[32m+[m[32m  cb(null, item * 2);[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32mMore examples could be found in [test/test-serial-object.js](test/test-serial-object.js).[m
[32m+[m
[32m+[m[32m_Note: Since _object_ is an _unordered_ collection of properties,[m
[32m+[m[32mit may produce unexpected results with sequential iterations.[m
[32m+[m[32mWhenever order of the jobs' execution is important please use `serialOrdered` method._[m
[32m+[m
[32m+[m[32m### Ordered Serial Iterations[m
[32m+[m
[32m+[m[32mTBD[m
[32m+[m
[32m+[m[32mFor example [compare-property](compare-property) package.[m
[32m+[m
[32m+[m[32m### Streaming interface[m
[32m+[m
[32m+[m[32mTBD[m
[32m+[m
[32m+[m[32m## Want to Know More?[m
[32m+[m
[32m+[m[32mMore examples can be found in [test folder](test/).[m
[32m+[m
[32m+[m[32mOr open an [issue](https://github.com/alexindigo/asynckit/issues) with questions and/or suggestions.[m
[32m+[m
[32m+[m[32m## License[m
[32m+[m
[32m+[m[32mAsyncKit is licensed under the MIT license.[m
[1mdiff --git a/node_modules/asynckit/bench.js b/node_modules/asynckit/bench.js[m
[1mnew file mode 100644[m
[1mindex 0000000..c612f1a[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/bench.js[m
[36m@@ -0,0 +1,76 @@[m
[32m+[m[32m/* eslint no-console: "off" */[m
[32m+[m
[32m+[m[32mvar asynckit = require('./')[m
[32m+[m[32m  , async    = require('async')[m
[32m+[m[32m  , assert   = require('assert')[m
[32m+[m[32m  , expected = 0[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32mvar Benchmark = require('benchmark');[m
[32m+[m[32mvar suite = new Benchmark.Suite;[m
[32m+[m
[32m+[m[32mvar source = [];[m
[32m+[m[32mfor (var z = 1; z < 100; z++)[m
[32m+[m[32m{[m
[32m+[m[32m  source.push(z);[m
[32m+[m[32m  expected += z;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32msuite[m
[32m+[m[32m// add tests[m
[32m+[m
[32m+[m[32m.add('async.map', function(deferred)[m
[32m+[m[32m{[m
[32m+[m[32m  var total = 0;[m
[32m+[m
[32m+[m[32m  async.map(source,[m
[32m+[m[32m  function(i, cb)[m
[32m+[m[32m  {[m
[32m+[m[32m    setImmediate(function()[m
[32m+[m[32m    {[m
[32m+[m[32m      total += i;[m
[32m+[m[32m      cb(null, total);[m
[32m+[m[32m    });[m
[32m+[m[32m  },[m
[32m+[m[32m  function(err, result)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert.ifError(err);[m
[32m+[m[32m    assert.equal(result[result.length - 1], expected);[m
[32m+[m[32m    deferred.resolve();[m
[32m+[m[32m  });[m
[32m+[m[32m}, {'defer': true})[m
[32m+[m
[32m+[m
[32m+[m[32m.add('asynckit.parallel', function(deferred)[m
[32m+[m[32m{[m
[32m+[m[32m  var total = 0;[m
[32m+[m
[32m+[m[32m  asynckit.parallel(source,[m
[32m+[m[32m  function(i, cb)[m
[32m+[m[32m  {[m
[32m+[m[32m    setImmediate(function()[m
[32m+[m[32m    {[m
[32m+[m[32m      total += i;[m
[32m+[m[32m      cb(null, total);[m
[32m+[m[32m    });[m
[32m+[m[32m  },[m
[32m+[m[32m  function(err, result)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert.ifError(err);[m
[32m+[m[32m    assert.equal(result[result.length - 1], expected);[m
[32m+[m[32m    deferred.resolve();[m
[32m+[m[32m  });[m
[32m+[m[32m}, {'defer': true})[m
[32m+[m
[32m+[m
[32m+[m[32m// add listeners[m
[32m+[m[32m.on('cycle', function(ev)[m
[32m+[m[32m{[m
[32m+[m[32m  console.log(String(ev.target));[m
[32m+[m[32m})[m
[32m+[m[32m.on('complete', function()[m
[32m+[m[32m{[m
[32m+[m[32m  console.log('Fastest is ' + this.filter('fastest').map('name'));[m
[32m+[m[32m})[m
[32m+[m[32m// run async[m
[32m+[m[32m.run({ 'async': true });[m
[1mdiff --git a/node_modules/asynckit/index.js b/node_modules/asynckit/index.js[m
[1mnew file mode 100644[m
[1mindex 0000000..455f945[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/index.js[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mmodule.exports =[m
[32m+[m[32m{[m
[32m+[m[32m  parallel      : require('./parallel.js'),[m
[32m+[m[32m  serial        : require('./serial.js'),[m
[32m+[m[32m  serialOrdered : require('./serialOrdered.js')[m
[32m+[m[32m};[m
[1mdiff --git a/node_modules/asynckit/lib/abort.js b/node_modules/asynckit/lib/abort.js[m
[1mnew file mode 100644[m
[1mindex 0000000..114367e[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/abort.js[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = abort;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Aborts leftover active jobs[m
[32m+[m[32m *[m
[32m+[m[32m * @param {object} state - current state object[m
[32m+[m[32m */[m
[32m+[m[32mfunction abort(state)[m
[32m+[m[32m{[m
[32m+[m[32m  Object.keys(state.jobs).forEach(clean.bind(state));[m
[32m+[m
[32m+[m[32m  // reset leftover jobs[m
[32m+[m[32m  state.jobs = {};[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Cleans up leftover job by invoking abort function for the provided job id[m
[32m+[m[32m *[m
[32m+[m[32m * @this  state[m
[32m+[m[32m * @param {string|number} key - job id to abort[m
[32m+[m[32m */[m
[32m+[m[32mfunction clean(key)[m
[32m+[m[32m{[m
[32m+[m[32m  if (typeof this.jobs[key] == 'function')[m
[32m+[m[32m  {[m
[32m+[m[32m    this.jobs[key]();[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/async.js b/node_modules/asynckit/lib/async.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7f1288a[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/async.js[m
[36m@@ -0,0 +1,34 @@[m
[32m+[m[32mvar defer = require('./defer.js');[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = async;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Runs provided callback asynchronously[m
[32m+[m[32m * even if callback itself is not[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {function} callback - callback to invoke[m
[32m+[m[32m * @returns {function} - augmented callback[m
[32m+[m[32m */[m
[32m+[m[32mfunction async(callback)[m
[32m+[m[32m{[m
[32m+[m[32m  var isAsync = false;[m
[32m+[m
[32m+[m[32m  // check if async happened[m
[32m+[m[32m  defer(function() { isAsync = true; });[m
[32m+[m
[32m+[m[32m  return function async_callback(err, result)[m
[32m+[m[32m  {[m
[32m+[m[32m    if (isAsync)[m
[32m+[m[32m    {[m
[32m+[m[32m      callback(err, result);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      defer(function nextTick_callback()[m
[32m+[m[32m      {[m
[32m+[m[32m        callback(err, result);[m
[32m+[m[32m      });[m
[32m+[m[32m    }[m
[32m+[m[32m  };[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/defer.js b/node_modules/asynckit/lib/defer.js[m
[1mnew file mode 100644[m
[1mindex 0000000..b67110c[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/defer.js[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mmodule.exports = defer;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Runs provided function on next iteration of the event loop[m
[32m+[m[32m *[m
[32m+[m[32m * @param {function} fn - function to run[m
[32m+[m[32m */[m
[32m+[m[32mfunction defer(fn)[m
[32m+[m[32m{[m
[32m+[m[32m  var nextTick = typeof setImmediate == 'function'[m
[32m+[m[32m    ? setImmediate[m
[32m+[m[32m    : ([m
[32m+[m[32m      typeof process == 'object' && typeof process.nextTick == 'function'[m
[32m+[m[32m      ? process.nextTick[m
[32m+[m[32m      : null[m
[32m+[m[32m    );[m
[32m+[m
[32m+[m[32m  if (nextTick)[m
[32m+[m[32m  {[m
[32m+[m[32m    nextTick(fn);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    setTimeout(fn, 0);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/iterate.js b/node_modules/asynckit/lib/iterate.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5d2839a[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/iterate.js[m
[36m@@ -0,0 +1,75 @@[m
[32m+[m[32mvar async = require('./async.js')[m
[32m+[m[32m  , abort = require('./abort.js')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = iterate;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Iterates over each job object[m
[32m+[m[32m *[m
[32m+[m[32m * @param {array|object} list - array or object (named list) to iterate over[m
[32m+[m[32m * @param {function} iterator - iterator to run[m
[32m+[m[32m * @param {object} state - current job status[m
[32m+[m[32m * @param {function} callback - invoked when all elements processed[m
[32m+[m[32m */[m
[32m+[m[32mfunction iterate(list, iterator, state, callback)[m
[32m+[m[32m{[m
[32m+[m[32m  // store current index[m
[32m+[m[32m  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;[m
[32m+[m
[32m+[m[32m  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)[m
[32m+[m[32m  {[m
[32m+[m[32m    // don't repeat yourself[m
[32m+[m[32m    // skip secondary callbacks[m
[32m+[m[32m    if (!(key in state.jobs))[m
[32m+[m[32m    {[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // clean up jobs[m
[32m+[m[32m    delete state.jobs[key];[m
[32m+[m
[32m+[m[32m    if (error)[m
[32m+[m[32m    {[m
[32m+[m[32m      // don't process rest of the results[m
[32m+[m[32m      // stop still active jobs[m
[32m+[m[32m      // and reset the list[m
[32m+[m[32m      abort(state);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      state.results[key] = output;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // return salvaged results[m
[32m+[m[32m    callback(error, state.results);[m
[32m+[m[32m  });[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Runs iterator over provided job element[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {function} iterator - iterator to invoke[m
[32m+[m[32m * @param   {string|number} key - key/index of the element in the list of jobs[m
[32m+[m[32m * @param   {mixed} item - job description[m
[32m+[m[32m * @param   {function} callback - invoked after iterator is done with the job[m
[32m+[m[32m * @returns {function|mixed} - job abort function or something else[m
[32m+[m[32m */[m
[32m+[m[32mfunction runJob(iterator, key, item, callback)[m
[32m+[m[32m{[m
[32m+[m[32m  var aborter;[m
[32m+[m
[32m+[m[32m  // allow shortcut if iterator expects only two arguments[m
[32m+[m[32m  if (iterator.length == 2)[m
[32m+[m[32m  {[m
[32m+[m[32m    aborter = iterator(item, async(callback));[m
[32m+[m[32m  }[m
[32m+[m[32m  // otherwise go with full three arguments[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    aborter = iterator(item, key, async(callback));[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return aborter;[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/readable_asynckit.js b/node_modules/asynckit/lib/readable_asynckit.js[m
[1mnew file mode 100644[m
[1mindex 0000000..78ad240[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/readable_asynckit.js[m
[36m@@ -0,0 +1,91 @@[m
[32m+[m[32mvar streamify = require('./streamify.js')[m
[32m+[m[32m  , defer     = require('./defer.js')[m
[32m+[m[32m  ;[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = ReadableAsyncKit;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Base constructor for all streams[m
[32m+[m[32m * used to hold properties/methods[m
[32m+[m[32m */[m
[32m+[m[32mfunction ReadableAsyncKit()[m
[32m+[m[32m{[m
[32m+[m[32m  ReadableAsyncKit.super_.apply(this, arguments);[m
[32m+[m
[32m+[m[32m  // list of active jobs[m
[32m+[m[32m  this.jobs = {};[m
[32m+[m
[32m+[m[32m  // add stream methods[m
[32m+[m[32m  this.destroy = destroy;[m
[32m+[m[32m  this._start  = _start;[m
[32m+[m[32m  this._read   = _read;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Destroys readable stream,[m
[32m+[m[32m * by aborting outstanding jobs[m
[32m+[m[32m *[m
[32m+[m[32m * @returns {void}[m
[32m+[m[32m */[m
[32m+[m[32mfunction destroy()[m
[32m+[m[32m{[m
[32m+[m[32m  if (this.destroyed)[m
[32m+[m[32m  {[m
[32m+[m[32m    return;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  this.destroyed = true;[m
[32m+[m
[32m+[m[32m  if (typeof this.terminator == 'function')[m
[32m+[m[32m  {[m
[32m+[m[32m    this.terminator();[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Starts provided jobs in async manner[m
[32m+[m[32m *[m
[32m+[m[32m * @private[m
[32m+[m[32m */[m
[32m+[m[32mfunction _start()[m
[32m+[m[32m{[m
[32m+[m[32m  // first argument â€“ runner function[m
[32m+[m[32m  var runner = arguments[0][m
[32m+[m[32m    // take away first argument[m
[32m+[m[32m    , args   = Array.prototype.slice.call(arguments, 1)[m
[32m+[m[32m      // second argument - input data[m
[32m+[m[32m    , input  = args[0][m
[32m+[m[32m      // last argument - result callback[m
[32m+[m[32m    , endCb  = streamify.callback.call(this, args[args.length - 1])[m
[32m+[m[32m    ;[m
[32m+[m
[32m+[m[32m  args[args.length - 1] = endCb;[m
[32m+[m[32m  // third argument - iterator[m
[32m+[m[32m  args[1] = streamify.iterator.call(this, args[1]);[m
[32m+[m
[32m+[m[32m  // allow time for proper setup[m
[32m+[m[32m  defer(function()[m
[32m+[m[32m  {[m
[32m+[m[32m    if (!this.destroyed)[m
[32m+[m[32m    {[m
[32m+[m[32m      this.terminator = runner.apply(null, args);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      endCb(null, Array.isArray(input) ? [] : {});[m
[32m+[m[32m    }[m
[32m+[m[32m  }.bind(this));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Implement _read to comply with Readable streams[m
[32m+[m[32m * Doesn't really make sense for flowing object mode[m
[32m+[m[32m *[m
[32m+[m[32m * @private[m
[32m+[m[32m */[m
[32m+[m[32mfunction _read()[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/readable_parallel.js b/node_modules/asynckit/lib/readable_parallel.js[m
[1mnew file mode 100644[m
[1mindex 0000000..5d2929f[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/readable_parallel.js[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mvar parallel = require('../parallel.js');[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = ReadableParallel;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Streaming wrapper to `asynckit.parallel`[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {array|object} list - array or object (named list) to iterate over[m
[32m+[m[32m * @param   {function} iterator - iterator to run[m
[32m+[m[32m * @param   {function} callback - invoked when all elements processed[m
[32m+[m[32m * @returns {stream.Readable#}[m
[32m+[m[32m */[m
[32m+[m[32mfunction ReadableParallel(list, iterator, callback)[m
[32m+[m[32m{[m
[32m+[m[32m  if (!(this instanceof ReadableParallel))[m
[32m+[m[32m  {[m
[32m+[m[32m    return new ReadableParallel(list, iterator, callback);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // turn on object mode[m
[32m+[m[32m  ReadableParallel.super_.call(this, {objectMode: true});[m
[32m+[m
[32m+[m[32m  this._start(parallel, list, iterator, callback);[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/readable_serial.js b/node_modules/asynckit/lib/readable_serial.js[m
[1mnew file mode 100644[m
[1mindex 0000000..7822698[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/readable_serial.js[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mvar serial = require('../serial.js');[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = ReadableSerial;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Streaming wrapper to `asynckit.serial`[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {array|object} list - array or object (named list) to iterate over[m
[32m+[m[32m * @param   {function} iterator - iterator to run[m
[32m+[m[32m * @param   {function} callback - invoked when all elements processed[m
[32m+[m[32m * @returns {stream.Readable#}[m
[32m+[m[32m */[m
[32m+[m[32mfunction ReadableSerial(list, iterator, callback)[m
[32m+[m[32m{[m
[32m+[m[32m  if (!(this instanceof ReadableSerial))[m
[32m+[m[32m  {[m
[32m+[m[32m    return new ReadableSerial(list, iterator, callback);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // turn on object mode[m
[32m+[m[32m  ReadableSerial.super_.call(this, {objectMode: true});[m
[32m+[m
[32m+[m[32m  this._start(serial, list, iterator, callback);[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/readable_serial_ordered.js b/node_modules/asynckit/lib/readable_serial_ordered.js[m
[1mnew file mode 100644[m
[1mindex 0000000..3de89c4[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/readable_serial_ordered.js[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mvar serialOrdered = require('../serialOrdered.js');[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = ReadableSerialOrdered;[m
[32m+[m[32m// expose sort helpers[m
[32m+[m[32mmodule.exports.ascending  = serialOrdered.ascending;[m
[32m+[m[32mmodule.exports.descending = serialOrdered.descending;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Streaming wrapper to `asynckit.serialOrdered`[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {array|object} list - array or object (named list) to iterate over[m
[32m+[m[32m * @param   {function} iterator - iterator to run[m
[32m+[m[32m * @param   {function} sortMethod - custom sort function[m
[32m+[m[32m * @param   {function} callback - invoked when all elements processed[m
[32m+[m[32m * @returns {stream.Readable#}[m
[32m+[m[32m */[m
[32m+[m[32mfunction ReadableSerialOrdered(list, iterator, sortMethod, callback)[m
[32m+[m[32m{[m
[32m+[m[32m  if (!(this instanceof ReadableSerialOrdered))[m
[32m+[m[32m  {[m
[32m+[m[32m    return new ReadableSerialOrdered(list, iterator, sortMethod, callback);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  // turn on object mode[m
[32m+[m[32m  ReadableSerialOrdered.super_.call(this, {objectMode: true});[m
[32m+[m
[32m+[m[32m  this._start(serialOrdered, list, iterator, sortMethod, callback);[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/state.js b/node_modules/asynckit/lib/state.js[m
[1mnew file mode 100644[m
[1mindex 0000000..cbea7ad[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/state.js[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = state;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Creates initial state object[m
[32m+[m[32m * for iteration over list[m
[32m+[m[32m *[m
[32m+[m[32m * @param   {array|object} list - list to iterate over[m
[32m+[m[32m * @param   {function|null} sortMethod - function to use for keys sort,[m
[32m+[m[32m *                                     or `null` to keep them as is[m
[32m+[m[32m * @returns {object} - initial state object[m
[32m+[m[32m */[m
[32m+[m[32mfunction state(list, sortMethod)[m
[32m+[m[32m{[m
[32m+[m[32m  var isNamedList = !Array.isArray(list)[m
[32m+[m[32m    , initState =[m
[32m+[m[32m    {[m
[32m+[m[32m      index    : 0,[m
[32m+[m[32m      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,[m
[32m+[m[32m      jobs     : {},[m
[32m+[m[32m      results  : isNamedList ? {} : [],[m
[32m+[m[32m      size     : isNamedList ? Object.keys(list).length : list.length[m
[32m+[m[32m    }[m
[32m+[m[32m    ;[m
[32m+[m
[32m+[m[32m  if (sortMethod)[m
[32m+[m[32m  {[m
[32m+[m[32m    // sort array keys based on it's values[m
[32m+[m[32m    // sort object's keys just on own merit[m
[32m+[m[32m    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)[m
[32m+[m[32m    {[m
[32m+[m[32m      return sortMethod(list[a], list[b]);[m
[32m+[m[32m    });[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return initState;[m
[32m+[m[32m}[m
[1mdiff --git a/node_modules/asynckit/lib/streamify.js b/node_modules/asynckit/lib/streamify.js[m
[1mnew file mode 100644[m
[1mindex 0000000..f56a1c9[m
[1m--- /dev/null[m
[1m+++ b/node_modules/asynckit/lib/streamify.js[m
[36m@@ -0,0 +1,141 @@[m
[32m+[m[32mvar async = require('./async.js');[m
[32m+[m
[32m+[m[32m// API[m
[32m+[m[32mmodule.exports = {[m
[32m+[m